
//
// Copyright (c) 2014 Limit Point Systems, Inc. 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

/// @file
/// Interface for class base_space_map.

#ifndef BASE_SPACE_MAP_H
#define BASE_SPACE_MAP_H

#ifndef SHEAF_DLL_SPEC_H
#include "SheafSystem/sheaf_dll_spec.h"
#endif

#ifndef ANY_H
#include "SheafSystem/any.h"
#endif

#ifndef FIELDS_H
#include "SheafSystem/fields.h"
#endif

#ifndef SECTION_PUSHER_PULLBACK_ACTION_H
#include "SheafSystem/section_pusher_pullback_action.h"
#endif

#ifndef SEC_ED_INVERTIBLE_H
#include "SheafSystem/sec_ed_invertible.h"
#endif

#ifndef SEC_REP_SPACE_H
#include "SheafSystem/sec_rep_space.h"
#endif

#ifndef STD_SET_H
#include "SheafSystem/std_set.h"
#endif

#ifndef STL_SCOPED_INDEX_H
#include "SheafSystem/stl_scoped_index.h"
#endif

namespace fiber_bundle
{
class base_space_poset;
class discretization_context;
class eval_iterator;
}

namespace fields
{

using namespace sheaf;
using namespace fiber_bundle; 

class base_space_map_push_action;
class field_vd;

///
/// A map from one base space to another generated by coordinate sections.
///
class SHEAF_DLL_SPEC base_space_map : public any
{

  // =============================================================================
  /// @name BASE_SPACE_MAP FACET
  // =============================================================================
  //@{

public:

  ///
  /// Copy constructor.
  ///
  base_space_map(const base_space_map& xother);

  ///
  /// Creates the map induced by xdomain_coord and xrange_coord.
  ///
  base_space_map(const sec_ed& xdomain_coord, const sec_ed& xrange_coord,
                 bool xauto_access);

  ///
  /// Destructor.
  ///
  virtual ~base_space_map();

  ///
  /// The domain of the push-forward map.
  ///
  const base_space_poset& domain() const;

  ///
  /// The coordinates section for the domain.
  ///
   const geometry::sec_ed_invertible& domain_coords() const;

  ///
  /// The range of the push-forward map.
  ///
   const base_space_poset& range() const;

  ///
  /// The coordinates section for the range.
  ///
   const sec_ed& range_coords() const;

  ///
  /// Pushes section xinput on domain() to xoutput on range().
  ///
  void push(const sec_vd& xinput, sec_vd& xoutput, bool xauto_access);

  ///
  /// Pushes each section in xinput on domain() to the corresponding
  /// section in xoutput on range().
  ///
  void push(const block<sec_vd*>& xinputs, block<sec_vd*>& xoutputs, bool xauto_access);

  ///
  /// True if and only if xsec1 and xsec2 have the same base space.
  ///
  bool same_base(const sec_vd& xsec1, const sec_vd& xsec2, bool xauto_access) const;

  ///
  /// True if and only if xsec1 and xsec2 have the same rep.
  ///
  bool same_rep(const sec_vd& xsec1, const sec_vd& xsec2, bool xauto_access) const;

  ///
  /// True if and only if xsec1 and xsec2 have the same fiber type and dimension.
  ///
  bool same_fiber(const sec_vd& xsec1, const sec_vd& xsec2, bool xauto_access) const;

  ///
  /// Computes value of destination dofs where dst overlaps src.
  ///
  base_space_map_push_action& overlap_action() const;

  ///
  /// Overlap action if none specified by clinet.
  ///
  base_space_map_push_action& default_overlap_action() const;

  ///
  /// Computes value of destination dofs where dst does not overlap src.
  ///
  base_space_map_push_action& extension_action() const;

  ///
  /// Extension action if none specified by clinet.
  ///
  base_space_map_push_action& default_extension_action() const;

  ///
  /// Sets the overlap action to xoverlap_action.
  ///
  void put_overlap_action(base_space_map_push_action& xoverlap_action);

  ///
  /// Sets the extension action to xextension_action.
  ///
  void put_extension_action(base_space_map_push_action& xextension_action);

protected:

  ///
  /// Default constructor; protected to prevent default construction.
  ///
  base_space_map();

private:

  ///
  /// The domain of this map.
  ///
  base_space_poset* _domain;

  ///
  /// The range of this map.
  ///
  base_space_poset* _range;

  ///
  /// The coordinates section for the domain.
  ///
  geometry::sec_ed_invertible _domain_coords;

  ///
  /// The coordinates section for the range.
  ///
  sec_ed _range_coords;

  ///
  /// The mapped type in the pullback map.
  ///
  typedef section_pusher_pullback_action::pb_type pb_type;

  ///
  /// The type for the domain evaluation member to output pullback map.
  ///
  typedef section_pusher_pullback_action::pb_map_type pb_map_type;

  ///
  /// The type of iterator for the pullback map.
  ///
  typedef section_pusher_pullback_action::pb_map_itr_type pb_map_itr_type;

  ///
  /// The type of iterator range for the pullback map.
  ///
  typedef section_pusher_pullback_action::pb_map_range_type pb_map_range_type;

  ///
  /// The domain evaluation member to output pullback map.
  ///
  block<pb_map_type*> _pb_maps;

  ///
  /// Type of pull back function.
  ///
  typedef void (base_space_map::*pull_back_function_type)(discretization_context&);

  ///
  /// Pulls the output disc back into the domain.
  ///
  void pull_back_output_disc(const sec_vd& xinput0,
                             section_space_schema_member& xoutput_schema);

  ///
  /// Pulls the output disc back into the domain
  /// for monosection source coordinates and monosection source property
  ///
  void pull_back_output_disc_mono_mono(const discretization_context& xcontext, pb_type& xpb);

  ///
  /// Pulls the output disc back into the domain
  /// for monosection source coordinates and multisection source property
  ///
  void pull_back_output_disc_mono_multi(const discretization_context& xcontext,
                                        pb_type& xpb,
                                        std::set< stl_scoped_index<> >& xbranches);

  ///
  /// Pulls the output disc back into the domain
  /// for multisection source coordinates and monosection source property
  ///
  void pull_back_output_disc_multi_mono(const discretization_context& xcontext, pb_type& xpb);

  ///
  /// Pulls the output disc back into the domain
  /// for multisection source coordinates and multisection source property
  ///
  void pull_back_output_disc_multi_multi(const discretization_context& xcontext, pb_type& xpb);

  ///
  /// The type of map from evaluation subposet member ids to branch base space ids.
  ///
  typedef hash_multimap<pod_index_type, scoped_index> chart_to_branch_map_type;

  ///
  /// Creates a map from evaluation subposet member ids to branch base space ids.
  ///
  chart_to_branch_map_type _chart_to_branch_map;

  ///
  /// The sequence id within the input block of
  /// the section used to control branch iteration.
  ///
  int _control_section;

  ///
  /// Sets _control_section to the first multisection in xinputs,
  /// if it exists, otherwise, sets _control section to the first section.
  ///
  void set_control_section(const block<sec_vd*>& xinputs);

  ///
  /// The poset id of the first branch.
  ///
  scoped_index _first_branch;

  ///
  /// The branch id space for the domain coordinates.
  ///
  index_space_handle* _coord_branch_id_space;

  ///
  /// The branch id spaces for any property multisections.
  ///
  block<index_space_handle*> _prop_branch_id_spaces;

  ///
  /// The branch id space for the cotrolling property.
  ///
  index_space_handle* _control_branch_id_space;

  ///
  /// Populates _branch_id_spaces.
  ///
  void set_branch_id_spaces(const block<sec_vd*>& xinputs);

  ///
  /// Allocates the branch pullback maps and
  /// populates the chart to branch map.
  ///
  void make_maps(sec_vd& xinput);

  ///
  /// Deallocates the branch pullback maps and
  /// depopulates the chart to branch map.
  ///
  void clear_maps();

  ///
  /// The fiber dimension of the src and dst property.
  ///
  int _prop_df;

  ///
  /// The base dimension of the domain.
  ///
  int _domain_db;

  ///
  /// A buffer for chart points.
  ///
  block<chart_point_3d> _chart_pts;

  ///
  /// A buffer for branch point pairs.
  ///
  block<branch_point_pair> _branch_pts;

  ///
  /// A buffer for gathering src dofs of an evaluation member.
  ///
  block< block<sec_vd_dof_type>* > _in_dofs;

  ///
  /// A buffer for computing dst dofs of a discretization member.
  ///
  block< block<sec_vd_dof_type>* > _out_dofs;

  ///
  /// Allocates the dof buffers.
  ///
  void make_dof_buffers(const block<sec_vd*>& xinputs, block<sec_vd*>& xoutputs);

  ///
  /// Deallocates the dof buffers.
  ///
  void clear_dof_buffers();

  ///
  /// Defines the part of the dst that overlaps the src;
  /// pushes the src to the dst
  ///
  void define_overlap(const block<sec_vd*>& xinputs, block<sec_vd*>& xoutputs);

  ///
  /// Pushes the current evaluation member of xeval_itr to the output.
  ///
  void push_eval_mbr(const eval_iterator& xeval_itr,
                     const block<sec_vd*>& xinputs,
                     block<sec_vd*>& xoutputs);

  ///
  /// Defines the part of the dst that does not over lap the src.
  ///
  void define_extension(block<sec_vd*>& xoutputs);

  ///
  /// Computes value of destination dofs where dst overlaps src.
  ///
  base_space_map_push_action* _overlap_action;

  ///
  /// Overlap action if none specified by user.
  ///
  base_space_map_push_action* _default_overlap_action;

  ///
  /// Computes value of destination dofs where dst does not overlap src.
  ///
  base_space_map_push_action* _extension_action;

  ///
  /// Extension action if none specified by user.
  ///
  base_space_map_push_action* _default_extension_action;

  ///
  /// Performs initialization common to several constructors.
  ///
  void initialize();

  //@}


  // =============================================================================
  /// @name ANY FACET
  // =============================================================================
  //@{

public:

  ///
  /// Class invariant.
  ///
  virtual bool invariant() const;

  //@}

};


// ===========================================================
// NONMEMBER FUNCTIONS
// ===========================================================
 
} // namespace fields

#endif // ifndef BASE_SPACE_MAP_H
